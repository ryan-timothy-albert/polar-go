// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"polar/internal/utils"
	"time"
)

// CheckoutCustomFieldData - Key-value object storing custom field values.
type CheckoutCustomFieldData struct {
}

type PaymentProcessorMetadata struct {
}

type CheckoutMetadataType string

const (
	CheckoutMetadataTypeStr     CheckoutMetadataType = "str"
	CheckoutMetadataTypeInteger CheckoutMetadataType = "integer"
	CheckoutMetadataTypeBoolean CheckoutMetadataType = "boolean"
)

type CheckoutMetadata struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`
	Boolean *bool   `queryParam:"inline"`

	Type CheckoutMetadataType
}

func CreateCheckoutMetadataStr(str string) CheckoutMetadata {
	typ := CheckoutMetadataTypeStr

	return CheckoutMetadata{
		Str:  &str,
		Type: typ,
	}
}

func CreateCheckoutMetadataInteger(integer int64) CheckoutMetadata {
	typ := CheckoutMetadataTypeInteger

	return CheckoutMetadata{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateCheckoutMetadataBoolean(boolean bool) CheckoutMetadata {
	typ := CheckoutMetadataTypeBoolean

	return CheckoutMetadata{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *CheckoutMetadata) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = CheckoutMetadataTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = CheckoutMetadataTypeInteger
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = &boolean
		u.Type = CheckoutMetadataTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CheckoutMetadata", string(data))
}

func (u CheckoutMetadata) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type CheckoutMetadata: all fields are null")
}

type CheckoutDiscountType string

const (
	CheckoutDiscountTypeCheckoutDiscountFixedOnceForeverDuration      CheckoutDiscountType = "CheckoutDiscountFixedOnceForeverDuration"
	CheckoutDiscountTypeCheckoutDiscountFixedRepeatDuration           CheckoutDiscountType = "CheckoutDiscountFixedRepeatDuration"
	CheckoutDiscountTypeCheckoutDiscountPercentageOnceForeverDuration CheckoutDiscountType = "CheckoutDiscountPercentageOnceForeverDuration"
	CheckoutDiscountTypeCheckoutDiscountPercentageRepeatDuration      CheckoutDiscountType = "CheckoutDiscountPercentageRepeatDuration"
)

type CheckoutDiscount struct {
	CheckoutDiscountFixedOnceForeverDuration      *CheckoutDiscountFixedOnceForeverDuration      `queryParam:"inline"`
	CheckoutDiscountFixedRepeatDuration           *CheckoutDiscountFixedRepeatDuration           `queryParam:"inline"`
	CheckoutDiscountPercentageOnceForeverDuration *CheckoutDiscountPercentageOnceForeverDuration `queryParam:"inline"`
	CheckoutDiscountPercentageRepeatDuration      *CheckoutDiscountPercentageRepeatDuration      `queryParam:"inline"`

	Type CheckoutDiscountType
}

func CreateCheckoutDiscountCheckoutDiscountFixedOnceForeverDuration(checkoutDiscountFixedOnceForeverDuration CheckoutDiscountFixedOnceForeverDuration) CheckoutDiscount {
	typ := CheckoutDiscountTypeCheckoutDiscountFixedOnceForeverDuration

	return CheckoutDiscount{
		CheckoutDiscountFixedOnceForeverDuration: &checkoutDiscountFixedOnceForeverDuration,
		Type:                                     typ,
	}
}

func CreateCheckoutDiscountCheckoutDiscountFixedRepeatDuration(checkoutDiscountFixedRepeatDuration CheckoutDiscountFixedRepeatDuration) CheckoutDiscount {
	typ := CheckoutDiscountTypeCheckoutDiscountFixedRepeatDuration

	return CheckoutDiscount{
		CheckoutDiscountFixedRepeatDuration: &checkoutDiscountFixedRepeatDuration,
		Type:                                typ,
	}
}

func CreateCheckoutDiscountCheckoutDiscountPercentageOnceForeverDuration(checkoutDiscountPercentageOnceForeverDuration CheckoutDiscountPercentageOnceForeverDuration) CheckoutDiscount {
	typ := CheckoutDiscountTypeCheckoutDiscountPercentageOnceForeverDuration

	return CheckoutDiscount{
		CheckoutDiscountPercentageOnceForeverDuration: &checkoutDiscountPercentageOnceForeverDuration,
		Type: typ,
	}
}

func CreateCheckoutDiscountCheckoutDiscountPercentageRepeatDuration(checkoutDiscountPercentageRepeatDuration CheckoutDiscountPercentageRepeatDuration) CheckoutDiscount {
	typ := CheckoutDiscountTypeCheckoutDiscountPercentageRepeatDuration

	return CheckoutDiscount{
		CheckoutDiscountPercentageRepeatDuration: &checkoutDiscountPercentageRepeatDuration,
		Type:                                     typ,
	}
}

func (u *CheckoutDiscount) UnmarshalJSON(data []byte) error {

	var checkoutDiscountPercentageOnceForeverDuration CheckoutDiscountPercentageOnceForeverDuration = CheckoutDiscountPercentageOnceForeverDuration{}
	if err := utils.UnmarshalJSON(data, &checkoutDiscountPercentageOnceForeverDuration, "", true, true); err == nil {
		u.CheckoutDiscountPercentageOnceForeverDuration = &checkoutDiscountPercentageOnceForeverDuration
		u.Type = CheckoutDiscountTypeCheckoutDiscountPercentageOnceForeverDuration
		return nil
	}

	var checkoutDiscountFixedOnceForeverDuration CheckoutDiscountFixedOnceForeverDuration = CheckoutDiscountFixedOnceForeverDuration{}
	if err := utils.UnmarshalJSON(data, &checkoutDiscountFixedOnceForeverDuration, "", true, true); err == nil {
		u.CheckoutDiscountFixedOnceForeverDuration = &checkoutDiscountFixedOnceForeverDuration
		u.Type = CheckoutDiscountTypeCheckoutDiscountFixedOnceForeverDuration
		return nil
	}

	var checkoutDiscountPercentageRepeatDuration CheckoutDiscountPercentageRepeatDuration = CheckoutDiscountPercentageRepeatDuration{}
	if err := utils.UnmarshalJSON(data, &checkoutDiscountPercentageRepeatDuration, "", true, true); err == nil {
		u.CheckoutDiscountPercentageRepeatDuration = &checkoutDiscountPercentageRepeatDuration
		u.Type = CheckoutDiscountTypeCheckoutDiscountPercentageRepeatDuration
		return nil
	}

	var checkoutDiscountFixedRepeatDuration CheckoutDiscountFixedRepeatDuration = CheckoutDiscountFixedRepeatDuration{}
	if err := utils.UnmarshalJSON(data, &checkoutDiscountFixedRepeatDuration, "", true, true); err == nil {
		u.CheckoutDiscountFixedRepeatDuration = &checkoutDiscountFixedRepeatDuration
		u.Type = CheckoutDiscountTypeCheckoutDiscountFixedRepeatDuration
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CheckoutDiscount", string(data))
}

func (u CheckoutDiscount) MarshalJSON() ([]byte, error) {
	if u.CheckoutDiscountFixedOnceForeverDuration != nil {
		return utils.MarshalJSON(u.CheckoutDiscountFixedOnceForeverDuration, "", true)
	}

	if u.CheckoutDiscountFixedRepeatDuration != nil {
		return utils.MarshalJSON(u.CheckoutDiscountFixedRepeatDuration, "", true)
	}

	if u.CheckoutDiscountPercentageOnceForeverDuration != nil {
		return utils.MarshalJSON(u.CheckoutDiscountPercentageOnceForeverDuration, "", true)
	}

	if u.CheckoutDiscountPercentageRepeatDuration != nil {
		return utils.MarshalJSON(u.CheckoutDiscountPercentageRepeatDuration, "", true)
	}

	return nil, errors.New("could not marshal union type CheckoutDiscount: all fields are null")
}

type CustomerMetadataType string

const (
	CustomerMetadataTypeStr     CustomerMetadataType = "str"
	CustomerMetadataTypeInteger CustomerMetadataType = "integer"
	CustomerMetadataTypeBoolean CustomerMetadataType = "boolean"
)

type CustomerMetadata struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`
	Boolean *bool   `queryParam:"inline"`

	Type CustomerMetadataType
}

func CreateCustomerMetadataStr(str string) CustomerMetadata {
	typ := CustomerMetadataTypeStr

	return CustomerMetadata{
		Str:  &str,
		Type: typ,
	}
}

func CreateCustomerMetadataInteger(integer int64) CustomerMetadata {
	typ := CustomerMetadataTypeInteger

	return CustomerMetadata{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateCustomerMetadataBoolean(boolean bool) CustomerMetadata {
	typ := CustomerMetadataTypeBoolean

	return CustomerMetadata{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *CustomerMetadata) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = CustomerMetadataTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = CustomerMetadataTypeInteger
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = &boolean
		u.Type = CustomerMetadataTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CustomerMetadata", string(data))
}

func (u CustomerMetadata) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type CustomerMetadata: all fields are null")
}

// Checkout session data retrieved using an access token.
type Checkout struct {
	// Creation timestamp of the object.
	CreatedAt time.Time `json:"created_at"`
	// Last modification timestamp of the object.
	ModifiedAt *time.Time `json:"modified_at"`
	// The ID of the object.
	ID string `json:"id"`
	// Key-value object storing custom field values.
	CustomFieldData  *CheckoutCustomFieldData `json:"custom_field_data,omitempty"`
	paymentProcessor PaymentProcessor         `const:"stripe" json:"payment_processor"`
	Status           CheckoutStatus           `json:"status"`
	// Client secret used to update and complete the checkout session from the client.
	ClientSecret string `json:"client_secret"`
	// URL where the customer can access the checkout session.
	URL string `json:"url"`
	// Expiration date and time of the checkout session.
	ExpiresAt time.Time `json:"expires_at"`
	// URL where the customer will be redirected after a successful payment.
	SuccessURL string `json:"success_url"`
	// When checkout is embedded, represents the Origin of the page embedding the checkout. Used as a security measure to send messages only to the embedding page.
	EmbedOrigin *string `json:"embed_origin"`
	Amount      *int64  `json:"amount"`
	// Computed tax amount to pay in cents.
	TaxAmount *int64 `json:"tax_amount"`
	// Currency code of the checkout session.
	Currency *string `json:"currency"`
	// Subtotal amount in cents, including discounts and before tax.
	SubtotalAmount *int64 `json:"subtotal_amount"`
	// Total amount to pay in cents, including discounts and after tax.
	TotalAmount *int64 `json:"total_amount"`
	// ID of the product to checkout.
	ProductID string `json:"product_id"`
	// ID of the product price to checkout.
	ProductPriceID string `json:"product_price_id"`
	// ID of the discount applied to the checkout.
	DiscountID *string `json:"discount_id"`
	// Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it'll still be applied, but the customer won't be able to change it.
	AllowDiscountCodes bool `json:"allow_discount_codes"`
	// Whether the discount is applicable to the checkout. Typically, free and custom prices are not discountable.
	IsDiscountApplicable bool `json:"is_discount_applicable"`
	// Whether the product price is free, regardless of discounts.
	IsFreeProductPrice bool `json:"is_free_product_price"`
	// Whether the checkout requires payment, e.g. in case of free products or discounts that cover the total amount.
	IsPaymentRequired bool `json:"is_payment_required"`
	// Whether the checkout requires setting up a payment method, regardless of the amount, e.g. subscriptions that have first free cycles.
	IsPaymentSetupRequired bool `json:"is_payment_setup_required"`
	// Whether the checkout requires a payment form, whether because of a payment or payment method setup.
	IsPaymentFormRequired    bool                        `json:"is_payment_form_required"`
	CustomerID               *string                     `json:"customer_id"`
	CustomerName             *string                     `json:"customer_name"`
	CustomerEmail            *string                     `json:"customer_email"`
	CustomerIPAddress        *string                     `json:"customer_ip_address"`
	CustomerBillingAddress   *Address                    `json:"customer_billing_address"`
	CustomerTaxID            *string                     `json:"customer_tax_id"`
	PaymentProcessorMetadata PaymentProcessorMetadata    `json:"payment_processor_metadata"`
	Metadata                 map[string]CheckoutMetadata `json:"metadata"`
	// Product data for a checkout session.
	Product              CheckoutProduct             `json:"product"`
	ProductPrice         ProductPrice                `json:"product_price"`
	Discount             *CheckoutDiscount           `json:"discount"`
	SubscriptionID       *string                     `json:"subscription_id"`
	AttachedCustomFields []AttachedCustomField       `json:"attached_custom_fields"`
	CustomerMetadata     map[string]CustomerMetadata `json:"customer_metadata"`
}

func (c Checkout) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *Checkout) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Checkout) GetCreatedAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.CreatedAt
}

func (o *Checkout) GetModifiedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.ModifiedAt
}

func (o *Checkout) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Checkout) GetCustomFieldData() *CheckoutCustomFieldData {
	if o == nil {
		return nil
	}
	return o.CustomFieldData
}

func (o *Checkout) GetPaymentProcessor() PaymentProcessor {
	return PaymentProcessorStripe
}

func (o *Checkout) GetStatus() CheckoutStatus {
	if o == nil {
		return CheckoutStatus("")
	}
	return o.Status
}

func (o *Checkout) GetClientSecret() string {
	if o == nil {
		return ""
	}
	return o.ClientSecret
}

func (o *Checkout) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *Checkout) GetExpiresAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.ExpiresAt
}

func (o *Checkout) GetSuccessURL() string {
	if o == nil {
		return ""
	}
	return o.SuccessURL
}

func (o *Checkout) GetEmbedOrigin() *string {
	if o == nil {
		return nil
	}
	return o.EmbedOrigin
}

func (o *Checkout) GetAmount() *int64 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *Checkout) GetTaxAmount() *int64 {
	if o == nil {
		return nil
	}
	return o.TaxAmount
}

func (o *Checkout) GetCurrency() *string {
	if o == nil {
		return nil
	}
	return o.Currency
}

func (o *Checkout) GetSubtotalAmount() *int64 {
	if o == nil {
		return nil
	}
	return o.SubtotalAmount
}

func (o *Checkout) GetTotalAmount() *int64 {
	if o == nil {
		return nil
	}
	return o.TotalAmount
}

func (o *Checkout) GetProductID() string {
	if o == nil {
		return ""
	}
	return o.ProductID
}

func (o *Checkout) GetProductPriceID() string {
	if o == nil {
		return ""
	}
	return o.ProductPriceID
}

func (o *Checkout) GetDiscountID() *string {
	if o == nil {
		return nil
	}
	return o.DiscountID
}

func (o *Checkout) GetAllowDiscountCodes() bool {
	if o == nil {
		return false
	}
	return o.AllowDiscountCodes
}

func (o *Checkout) GetIsDiscountApplicable() bool {
	if o == nil {
		return false
	}
	return o.IsDiscountApplicable
}

func (o *Checkout) GetIsFreeProductPrice() bool {
	if o == nil {
		return false
	}
	return o.IsFreeProductPrice
}

func (o *Checkout) GetIsPaymentRequired() bool {
	if o == nil {
		return false
	}
	return o.IsPaymentRequired
}

func (o *Checkout) GetIsPaymentSetupRequired() bool {
	if o == nil {
		return false
	}
	return o.IsPaymentSetupRequired
}

func (o *Checkout) GetIsPaymentFormRequired() bool {
	if o == nil {
		return false
	}
	return o.IsPaymentFormRequired
}

func (o *Checkout) GetCustomerID() *string {
	if o == nil {
		return nil
	}
	return o.CustomerID
}

func (o *Checkout) GetCustomerName() *string {
	if o == nil {
		return nil
	}
	return o.CustomerName
}

func (o *Checkout) GetCustomerEmail() *string {
	if o == nil {
		return nil
	}
	return o.CustomerEmail
}

func (o *Checkout) GetCustomerIPAddress() *string {
	if o == nil {
		return nil
	}
	return o.CustomerIPAddress
}

func (o *Checkout) GetCustomerBillingAddress() *Address {
	if o == nil {
		return nil
	}
	return o.CustomerBillingAddress
}

func (o *Checkout) GetCustomerTaxID() *string {
	if o == nil {
		return nil
	}
	return o.CustomerTaxID
}

func (o *Checkout) GetPaymentProcessorMetadata() PaymentProcessorMetadata {
	if o == nil {
		return PaymentProcessorMetadata{}
	}
	return o.PaymentProcessorMetadata
}

func (o *Checkout) GetMetadata() map[string]CheckoutMetadata {
	if o == nil {
		return map[string]CheckoutMetadata{}
	}
	return o.Metadata
}

func (o *Checkout) GetProduct() CheckoutProduct {
	if o == nil {
		return CheckoutProduct{}
	}
	return o.Product
}

func (o *Checkout) GetProductPrice() ProductPrice {
	if o == nil {
		return ProductPrice{}
	}
	return o.ProductPrice
}

func (o *Checkout) GetDiscount() *CheckoutDiscount {
	if o == nil {
		return nil
	}
	return o.Discount
}

func (o *Checkout) GetSubscriptionID() *string {
	if o == nil {
		return nil
	}
	return o.SubscriptionID
}

func (o *Checkout) GetAttachedCustomFields() []AttachedCustomField {
	if o == nil {
		return []AttachedCustomField{}
	}
	return o.AttachedCustomFields
}

func (o *Checkout) GetCustomerMetadata() map[string]CustomerMetadata {
	if o == nil {
		return map[string]CustomerMetadata{}
	}
	return o.CustomerMetadata
}
