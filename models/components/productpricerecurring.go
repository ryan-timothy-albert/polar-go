// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"polar/internal/utils"
)

type ProductPriceRecurringType string

const (
	ProductPriceRecurringTypeProductPriceRecurringFixed  ProductPriceRecurringType = "ProductPriceRecurringFixed"
	ProductPriceRecurringTypeProductPriceRecurringCustom ProductPriceRecurringType = "ProductPriceRecurringCustom"
	ProductPriceRecurringTypeProductPriceRecurringFree   ProductPriceRecurringType = "ProductPriceRecurringFree"
)

type ProductPriceRecurring struct {
	ProductPriceRecurringFixed  *ProductPriceRecurringFixed  `queryParam:"inline"`
	ProductPriceRecurringCustom *ProductPriceRecurringCustom `queryParam:"inline"`
	ProductPriceRecurringFree   *ProductPriceRecurringFree   `queryParam:"inline"`

	Type ProductPriceRecurringType
}

func CreateProductPriceRecurringProductPriceRecurringFixed(productPriceRecurringFixed ProductPriceRecurringFixed) ProductPriceRecurring {
	typ := ProductPriceRecurringTypeProductPriceRecurringFixed

	return ProductPriceRecurring{
		ProductPriceRecurringFixed: &productPriceRecurringFixed,
		Type:                       typ,
	}
}

func CreateProductPriceRecurringProductPriceRecurringCustom(productPriceRecurringCustom ProductPriceRecurringCustom) ProductPriceRecurring {
	typ := ProductPriceRecurringTypeProductPriceRecurringCustom

	return ProductPriceRecurring{
		ProductPriceRecurringCustom: &productPriceRecurringCustom,
		Type:                        typ,
	}
}

func CreateProductPriceRecurringProductPriceRecurringFree(productPriceRecurringFree ProductPriceRecurringFree) ProductPriceRecurring {
	typ := ProductPriceRecurringTypeProductPriceRecurringFree

	return ProductPriceRecurring{
		ProductPriceRecurringFree: &productPriceRecurringFree,
		Type:                      typ,
	}
}

func (u *ProductPriceRecurring) UnmarshalJSON(data []byte) error {

	var productPriceRecurringFree ProductPriceRecurringFree = ProductPriceRecurringFree{}
	if err := utils.UnmarshalJSON(data, &productPriceRecurringFree, "", true, true); err == nil {
		u.ProductPriceRecurringFree = &productPriceRecurringFree
		u.Type = ProductPriceRecurringTypeProductPriceRecurringFree
		return nil
	}

	var productPriceRecurringFixed ProductPriceRecurringFixed = ProductPriceRecurringFixed{}
	if err := utils.UnmarshalJSON(data, &productPriceRecurringFixed, "", true, true); err == nil {
		u.ProductPriceRecurringFixed = &productPriceRecurringFixed
		u.Type = ProductPriceRecurringTypeProductPriceRecurringFixed
		return nil
	}

	var productPriceRecurringCustom ProductPriceRecurringCustom = ProductPriceRecurringCustom{}
	if err := utils.UnmarshalJSON(data, &productPriceRecurringCustom, "", true, true); err == nil {
		u.ProductPriceRecurringCustom = &productPriceRecurringCustom
		u.Type = ProductPriceRecurringTypeProductPriceRecurringCustom
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProductPriceRecurring", string(data))
}

func (u ProductPriceRecurring) MarshalJSON() ([]byte, error) {
	if u.ProductPriceRecurringFixed != nil {
		return utils.MarshalJSON(u.ProductPriceRecurringFixed, "", true)
	}

	if u.ProductPriceRecurringCustom != nil {
		return utils.MarshalJSON(u.ProductPriceRecurringCustom, "", true)
	}

	if u.ProductPriceRecurringFree != nil {
		return utils.MarshalJSON(u.ProductPriceRecurringFree, "", true)
	}

	return nil, errors.New("could not marshal union type ProductPriceRecurring: all fields are null")
}
