// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"github.com/polarsource/polar-go/internal/utils"
)

type ProductUpdateMetadataType string

const (
	ProductUpdateMetadataTypeStr     ProductUpdateMetadataType = "str"
	ProductUpdateMetadataTypeInteger ProductUpdateMetadataType = "integer"
	ProductUpdateMetadataTypeBoolean ProductUpdateMetadataType = "boolean"
)

type ProductUpdateMetadata struct {
	Str     *string `queryParam:"inline"`
	Integer *int64  `queryParam:"inline"`
	Boolean *bool   `queryParam:"inline"`

	Type ProductUpdateMetadataType
}

func CreateProductUpdateMetadataStr(str string) ProductUpdateMetadata {
	typ := ProductUpdateMetadataTypeStr

	return ProductUpdateMetadata{
		Str:  &str,
		Type: typ,
	}
}

func CreateProductUpdateMetadataInteger(integer int64) ProductUpdateMetadata {
	typ := ProductUpdateMetadataTypeInteger

	return ProductUpdateMetadata{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateProductUpdateMetadataBoolean(boolean bool) ProductUpdateMetadata {
	typ := ProductUpdateMetadataTypeBoolean

	return ProductUpdateMetadata{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *ProductUpdateMetadata) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ProductUpdateMetadataTypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, true); err == nil {
		u.Integer = &integer
		u.Type = ProductUpdateMetadataTypeInteger
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = &boolean
		u.Type = ProductUpdateMetadataTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProductUpdateMetadata", string(data))
}

func (u ProductUpdateMetadata) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type ProductUpdateMetadata: all fields are null")
}

type ProductUpdatePricesType string

const (
	ProductUpdatePricesTypeExistingProductPrice             ProductUpdatePricesType = "ExistingProductPrice"
	ProductUpdatePricesTypeProductPriceRecurringFixedCreate ProductUpdatePricesType = "ProductPriceRecurringFixedCreate"
	ProductUpdatePricesTypeProductPriceRecurringFreeCreate  ProductUpdatePricesType = "ProductPriceRecurringFreeCreate"
	ProductUpdatePricesTypeProductPriceOneTimeFixedCreate   ProductUpdatePricesType = "ProductPriceOneTimeFixedCreate"
	ProductUpdatePricesTypeProductPriceOneTimeCustomCreate  ProductUpdatePricesType = "ProductPriceOneTimeCustomCreate"
	ProductUpdatePricesTypeProductPriceOneTimeFreeCreate    ProductUpdatePricesType = "ProductPriceOneTimeFreeCreate"
)

type ProductUpdatePrices struct {
	ExistingProductPrice             *ExistingProductPrice             `queryParam:"inline"`
	ProductPriceRecurringFixedCreate *ProductPriceRecurringFixedCreate `queryParam:"inline"`
	ProductPriceRecurringFreeCreate  *ProductPriceRecurringFreeCreate  `queryParam:"inline"`
	ProductPriceOneTimeFixedCreate   *ProductPriceOneTimeFixedCreate   `queryParam:"inline"`
	ProductPriceOneTimeCustomCreate  *ProductPriceOneTimeCustomCreate  `queryParam:"inline"`
	ProductPriceOneTimeFreeCreate    *ProductPriceOneTimeFreeCreate    `queryParam:"inline"`

	Type ProductUpdatePricesType
}

func CreateProductUpdatePricesExistingProductPrice(existingProductPrice ExistingProductPrice) ProductUpdatePrices {
	typ := ProductUpdatePricesTypeExistingProductPrice

	return ProductUpdatePrices{
		ExistingProductPrice: &existingProductPrice,
		Type:                 typ,
	}
}

func CreateProductUpdatePricesProductPriceRecurringFixedCreate(productPriceRecurringFixedCreate ProductPriceRecurringFixedCreate) ProductUpdatePrices {
	typ := ProductUpdatePricesTypeProductPriceRecurringFixedCreate

	return ProductUpdatePrices{
		ProductPriceRecurringFixedCreate: &productPriceRecurringFixedCreate,
		Type:                             typ,
	}
}

func CreateProductUpdatePricesProductPriceRecurringFreeCreate(productPriceRecurringFreeCreate ProductPriceRecurringFreeCreate) ProductUpdatePrices {
	typ := ProductUpdatePricesTypeProductPriceRecurringFreeCreate

	return ProductUpdatePrices{
		ProductPriceRecurringFreeCreate: &productPriceRecurringFreeCreate,
		Type:                            typ,
	}
}

func CreateProductUpdatePricesProductPriceOneTimeFixedCreate(productPriceOneTimeFixedCreate ProductPriceOneTimeFixedCreate) ProductUpdatePrices {
	typ := ProductUpdatePricesTypeProductPriceOneTimeFixedCreate

	return ProductUpdatePrices{
		ProductPriceOneTimeFixedCreate: &productPriceOneTimeFixedCreate,
		Type:                           typ,
	}
}

func CreateProductUpdatePricesProductPriceOneTimeCustomCreate(productPriceOneTimeCustomCreate ProductPriceOneTimeCustomCreate) ProductUpdatePrices {
	typ := ProductUpdatePricesTypeProductPriceOneTimeCustomCreate

	return ProductUpdatePrices{
		ProductPriceOneTimeCustomCreate: &productPriceOneTimeCustomCreate,
		Type:                            typ,
	}
}

func CreateProductUpdatePricesProductPriceOneTimeFreeCreate(productPriceOneTimeFreeCreate ProductPriceOneTimeFreeCreate) ProductUpdatePrices {
	typ := ProductUpdatePricesTypeProductPriceOneTimeFreeCreate

	return ProductUpdatePrices{
		ProductPriceOneTimeFreeCreate: &productPriceOneTimeFreeCreate,
		Type:                          typ,
	}
}

func (u *ProductUpdatePrices) UnmarshalJSON(data []byte) error {

	var existingProductPrice ExistingProductPrice = ExistingProductPrice{}
	if err := utils.UnmarshalJSON(data, &existingProductPrice, "", true, true); err == nil {
		u.ExistingProductPrice = &existingProductPrice
		u.Type = ProductUpdatePricesTypeExistingProductPrice
		return nil
	}

	var productPriceOneTimeFreeCreate ProductPriceOneTimeFreeCreate = ProductPriceOneTimeFreeCreate{}
	if err := utils.UnmarshalJSON(data, &productPriceOneTimeFreeCreate, "", true, true); err == nil {
		u.ProductPriceOneTimeFreeCreate = &productPriceOneTimeFreeCreate
		u.Type = ProductUpdatePricesTypeProductPriceOneTimeFreeCreate
		return nil
	}

	var productPriceRecurringFreeCreate ProductPriceRecurringFreeCreate = ProductPriceRecurringFreeCreate{}
	if err := utils.UnmarshalJSON(data, &productPriceRecurringFreeCreate, "", true, true); err == nil {
		u.ProductPriceRecurringFreeCreate = &productPriceRecurringFreeCreate
		u.Type = ProductUpdatePricesTypeProductPriceRecurringFreeCreate
		return nil
	}

	var productPriceOneTimeFixedCreate ProductPriceOneTimeFixedCreate = ProductPriceOneTimeFixedCreate{}
	if err := utils.UnmarshalJSON(data, &productPriceOneTimeFixedCreate, "", true, true); err == nil {
		u.ProductPriceOneTimeFixedCreate = &productPriceOneTimeFixedCreate
		u.Type = ProductUpdatePricesTypeProductPriceOneTimeFixedCreate
		return nil
	}

	var productPriceRecurringFixedCreate ProductPriceRecurringFixedCreate = ProductPriceRecurringFixedCreate{}
	if err := utils.UnmarshalJSON(data, &productPriceRecurringFixedCreate, "", true, true); err == nil {
		u.ProductPriceRecurringFixedCreate = &productPriceRecurringFixedCreate
		u.Type = ProductUpdatePricesTypeProductPriceRecurringFixedCreate
		return nil
	}

	var productPriceOneTimeCustomCreate ProductPriceOneTimeCustomCreate = ProductPriceOneTimeCustomCreate{}
	if err := utils.UnmarshalJSON(data, &productPriceOneTimeCustomCreate, "", true, true); err == nil {
		u.ProductPriceOneTimeCustomCreate = &productPriceOneTimeCustomCreate
		u.Type = ProductUpdatePricesTypeProductPriceOneTimeCustomCreate
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProductUpdatePrices", string(data))
}

func (u ProductUpdatePrices) MarshalJSON() ([]byte, error) {
	if u.ExistingProductPrice != nil {
		return utils.MarshalJSON(u.ExistingProductPrice, "", true)
	}

	if u.ProductPriceRecurringFixedCreate != nil {
		return utils.MarshalJSON(u.ProductPriceRecurringFixedCreate, "", true)
	}

	if u.ProductPriceRecurringFreeCreate != nil {
		return utils.MarshalJSON(u.ProductPriceRecurringFreeCreate, "", true)
	}

	if u.ProductPriceOneTimeFixedCreate != nil {
		return utils.MarshalJSON(u.ProductPriceOneTimeFixedCreate, "", true)
	}

	if u.ProductPriceOneTimeCustomCreate != nil {
		return utils.MarshalJSON(u.ProductPriceOneTimeCustomCreate, "", true)
	}

	if u.ProductPriceOneTimeFreeCreate != nil {
		return utils.MarshalJSON(u.ProductPriceOneTimeFreeCreate, "", true)
	}

	return nil, errors.New("could not marshal union type ProductUpdatePrices: all fields are null")
}

// ProductUpdate - Schema to update a product.
type ProductUpdate struct {
	Metadata map[string]ProductUpdateMetadata `json:"metadata,omitempty"`
	Name     *string                          `json:"name,omitempty"`
	// The description of the product.
	Description *string `json:"description,omitempty"`
	// Whether the product is archived. If `true`, the product won't be available for purchase anymore. Existing customers will still have access to their benefits, and subscriptions will continue normally.
	IsArchived *bool `json:"is_archived,omitempty"`
	// List of available prices for this product. If you want to keep existing prices, include them in the list as an `ExistingProductPrice` object.
	Prices []ProductUpdatePrices `json:"prices,omitempty"`
	// List of file IDs. Each one must be on the same organization as the product, of type `product_media` and correctly uploaded.
	Medias               []string                    `json:"medias,omitempty"`
	AttachedCustomFields []AttachedCustomFieldCreate `json:"attached_custom_fields,omitempty"`
}

func (o *ProductUpdate) GetMetadata() map[string]ProductUpdateMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *ProductUpdate) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *ProductUpdate) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *ProductUpdate) GetIsArchived() *bool {
	if o == nil {
		return nil
	}
	return o.IsArchived
}

func (o *ProductUpdate) GetPrices() []ProductUpdatePrices {
	if o == nil {
		return nil
	}
	return o.Prices
}

func (o *ProductUpdate) GetMedias() []string {
	if o == nil {
		return nil
	}
	return o.Medias
}

func (o *ProductUpdate) GetAttachedCustomFields() []AttachedCustomFieldCreate {
	if o == nil {
		return nil
	}
	return o.AttachedCustomFields
}
